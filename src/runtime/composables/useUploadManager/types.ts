import type { Emitter } from "mitt"

/**
 * PUBLIC API - Types users commonly need
 * These are exported from the main package
 */

// Core file and upload types
export type FileStatus = "waiting" | "preprocessing" | "uploading" | "postprocessing" | "complete" | "error"
export type UploadStatus = "waiting" | "uploading"

export interface FileProgress {
  percentage: number
}

export interface FileError {
  message: string
  details?: unknown
}

/**
 * File source - indicates where the file originated from
 *
 * - 'local': File selected from user's device
 * - 'storage': File loaded from remote storage (was previously uploaded)
 * - Cloud picker sources: Files picked from cloud providers (future)
 *   - 'instagram': Instagram picker
 *   - 'dropbox': Dropbox picker
 *   - 'google-drive': Google Drive picker
 *   - 'onedrive': OneDrive picker
 *   - ... add more as needed
 */
export type FileSource = "local" | "storage" | "instagram" | "dropbox" | "google-drive" | "onedrive"

/**
 * Base properties shared by both local and remote upload files
 */
export interface BaseUploadFile<TUploadResult = any> {
  /** Unique identifier for the file */
  id: string

  /** Original filename (e.g., "vacation-photo.jpg") */
  name: string

  /** File size in bytes */
  size: number

  /** MIME type (e.g., "image/jpeg", "video/mp4") */
  mimeType: string

  /**
   * Current upload status
   */
  status: FileStatus

  /**
   * Preview URL for displaying in UI (always populated after initialization)
   * - For local files: Generated by thumbnail plugin as data URL, or remoteUrl after upload
   * - For remote files: Provided by backend/storage, or falls back to remoteUrl
   * - No manual fallback needed: Always available for display
   */
  preview?: string

  /** Upload progress tracking */
  progress: FileProgress

  /** Error information if upload fails */
  error?: FileError

  /**
   * Result returned by the upload function/storage plugin
   * Can contain additional metadata like etag, key, etc.
   */
  uploadResult?: TUploadResult

  /**
   * Custom metadata for storing additional file information
   * Plugins can add data here (e.g., { extension: 'jpg', originalWidth: 4000 })
   */
  meta: Record<string, unknown>
}

/**
 * Local upload file - originates from user's device
 *
 * Lifecycle:
 * 1. User selects file → created with data, no remoteUrl
 * 2. Validation → runs validate hooks
 * 3. Preprocessing → generates thumbnails (preview set here)
 * 4. User clicks upload → runs process hooks (compression)
 * 5. Upload → remoteUrl set after successful upload
 *
 * @example
 * ```typescript
 * const localFile: LocalUploadFile = {
 *   source: 'local',
 *   data: fileBlob,        // Has local data
 *   remoteUrl: undefined,  // Not uploaded yet
 *   preview: 'data:image/jpeg;base64,...', // Generated by thumbnail plugin
 *   ...
 * }
 * ```
 */
export interface LocalUploadFile<TUploadResult = any> extends BaseUploadFile<TUploadResult> {
  /** Always 'local' for files selected from user's device */
  source: "local"

  /**
   * The actual file data (File from input or Blob)
   * Available for processing, compression, thumbnail generation, etc.
   */
  data: File | Blob

  /**
   * URL where file was uploaded (set after successful upload)
   * undefined before upload, populated after upload completes
   * Use to check if file has been uploaded: `if (file.remoteUrl) { ... }`
   */
  remoteUrl?: string
}

/**
 * Remote upload file - originates from remote source
 *
 * These files already exist remotely and don't need uploading.
 * Common sources:
 * - 'storage': Previously uploaded files being re-loaded
 * - 'instagram', 'dropbox', etc.: Files from cloud pickers
 *
 * @example
 * ```typescript
 * const remoteFile: RemoteUploadFile = {
 *   source: 'storage',
 *   data: null,           // No local data - file is remote
 *   remoteUrl: 'https://storage.com/file.jpg',  // Always present
 *   preview: 'https://storage.com/thumbnails/file.jpg', // Optional, from backend
 *   status: 'complete',   // Already uploaded
 *   ...
 * }
 * ```
 */
export interface RemoteUploadFile<TUploadResult = any> extends BaseUploadFile<TUploadResult> {
  /**
   * Source of the remote file
   * - 'storage': File from your storage (previously uploaded)
   * - 'instagram', 'dropbox', etc.: File from cloud picker
   */
  source: Exclude<FileSource, "local">

  /**
   * Always null for remote files (no local data available)
   * File exists remotely and is accessed via remoteUrl
   */
  data: null

  /**
   * URL to the remote file (always present for remote files)
   * Use this to display/download the file
   */
  remoteUrl: string
}

/**
 * Upload file discriminated union
 * Use file.source to narrow the type in your code:
 *
 * @example
 * ```typescript
 * if (file.source === 'local') {
 *   // TypeScript knows: file is LocalUploadFile
 *   URL.createObjectURL(file.data)
 * } else {
 *   // TypeScript knows: file is RemoteUploadFile
 *   console.log(file.remoteUrl)
 * }
 * ```
 */
export type UploadFile<TUploadResult = any> = LocalUploadFile<TUploadResult> | RemoteUploadFile<TUploadResult>

// User callback types
export type UploadFn<TUploadResult = any> = (
  file: UploadFile<TUploadResult>,
  onProgress: (progress: number) => void,
) => Promise<TUploadResult>

export type GetRemoteFileFn = (fileId: string) => Promise<MinimumRemoteFileAttributes>

// Configuration
export interface UploadOptions {
  /**
   * Storage plugin for uploading files (only one storage plugin can be active)
   *
   * Storage plugins handle the actual upload, download, and deletion of files
   * from remote storage (Azure, S3, GCS, etc.)
   *
   * @example
   * ```typescript
   * storage: PluginAzureDataLake({
   *   sasURL: 'https://...',
   *   path: 'uploads'
   * })
   * ```
   */
  storage?: StoragePlugin<any, any>

  /**
   * Processing and validation plugins (validators, compressors, etc.)
   *
   * These plugins run during the file lifecycle:
   * - validate: Check file before adding
   * - preprocess: Generate thumbnails/previews immediately
   * - process: Compress/transform before upload
   * - complete: Post-upload processing
   *
   * @example
   * ```typescript
   * plugins: [
   *   ValidatorMaxFiles({ maxFiles: 10 }),
   *   PluginImageCompressor({ quality: 0.8 })
   * ]
   * ```
   */
  plugins?: ProcessingPlugin<any, any>[]

  /**
   * Validate maximum number of files
   * - false: disabled
   * - number: enabled with limit
   * @default false
   */
  maxFiles?: false | number

  /**
   * Validate maximum file size in bytes
   * - false: disabled
   * - number: enabled with limit
   * @default false
   */
  maxFileSize?: false | number

  /**
   * Validate allowed file MIME types
   * - false: disabled
   * - string[]: enabled with allowed types
   * @default false
   */
  allowedFileTypes?: false | string[]

  /**
   * Generate thumbnail previews for images/videos
   * - false: disabled
   * - true: enabled with defaults
   * - object: enabled with custom options
   * @default false
   */
  thumbnails?: false | true | ThumbnailOptions

  /**
   * Compress images before upload
   * - false: disabled
   * - true: enabled with defaults
   * - object: enabled with custom options
   * @default false
   */
  imageCompression?: false | true | ImageCompressionOptions

  /**
   * Automatically start upload after files are added
   * @default false
   */
  autoProceed?: boolean
}

export interface ThumbnailOptions {
  width?: number
  height?: number
  quality?: number
}

export interface ImageCompressionOptions {
  maxWidth?: number
  maxHeight?: number
  quality?: number
  outputFormat?: "jpeg" | "webp" | "png" | "auto"
  minSizeToCompress?: number
  preserveMetadata?: boolean
}

// Core events (always available)
type CoreUploaderEvents<TUploadResult = any> = {
  "file:added": Readonly<UploadFile<TUploadResult>>
  "file:removed": Readonly<UploadFile<TUploadResult>>
  "file:replaced": Readonly<UploadFile<TUploadResult>>
  "file:processing": Readonly<UploadFile<TUploadResult>>
  "file:error": { file: Readonly<UploadFile<TUploadResult>>; error: FileError }
  "upload:start": Array<Readonly<UploadFile<TUploadResult>>>
  "upload:complete": Array<Required<Readonly<UploadFile<TUploadResult>>>>
  "upload:error": FileError
  "upload:progress": { file: Readonly<UploadFile<TUploadResult>>; progress: number }
  "files:reorder": { oldIndex: number; newIndex: number }
}

// Events for listening - only core events are typed, plugins can emit arbitrary events
export type UploaderEvents<TUploadResult = any> = CoreUploaderEvents<TUploadResult>

/**
 * PLUGIN API - Types for building custom plugins
 * Only needed if users want to create custom validators/processors
 */

export type PluginContext<TPluginEvents extends Record<string, any> = Record<string, never>> = {
  files: UploadFile[]
  options: UploadOptions
  /**
   * Emit custom plugin events
   * Events are automatically prefixed with the plugin ID
   */
  emit: <K extends keyof TPluginEvents>(event: K, payload: TPluginEvents[K]) => void
}

export type ValidationHook<TPluginEvents extends Record<string, any> = Record<string, never>> = (
  file: UploadFile,
  context: PluginContext<TPluginEvents>,
) => Promise<true | UploadFile>
export type ProcessingHook<TPluginEvents extends Record<string, any> = Record<string, never>> = (
  file: UploadFile,
  context: PluginContext<TPluginEvents>,
) => Promise<UploadFile>
export type SetupHook<TPluginEvents extends Record<string, any> = Record<string, never>> = (
  context: PluginContext<TPluginEvents>,
) => Promise<void>

/**
 * Storage hooks for handling upload/download/deletion operations
 *
 * Storage plugins MUST return an object containing a `url` property.
 * This URL will be set as the file's `remoteUrl` after successful upload.
 *
 * @example
 * ```typescript
 * upload: async (file, context) => {
 *   // Upload logic...
 *   return {
 *     url: 'https://storage.example.com/file.jpg',  // Required
 *     key: 'uploads/file.jpg',                      // Optional
 *     etag: 'abc123'                                // Optional
 *   }
 * }
 * ```
 */
export type UploadHook<TUploadResult = any, TPluginEvents extends Record<string, any> = Record<string, never>> = (
  file: UploadFile<TUploadResult>,
  context: PluginContext<TPluginEvents> & { onProgress: (progress: number) => void },
) => Promise<TUploadResult & { url: string }>

export type GetRemoteFileHook<TPluginEvents extends Record<string, any> = Record<string, never>> = (
  fileId: string,
  context: PluginContext<TPluginEvents>,
) => Promise<MinimumRemoteFileAttributes>

export type RemoveHook<TPluginEvents extends Record<string, any> = Record<string, never>> = (
  file: UploadFile,
  context: PluginContext<TPluginEvents>,
) => Promise<void>

export type PluginLifecycleStage = "validate" | "preprocess" | "process" | "upload" | "complete"

/**
 * Processing plugin hooks (validators, compressors, thumbnail generators)
 */
export type ProcessingPluginHooks<TPluginEvents extends Record<string, any> = Record<string, never>> = {
  validate?: ValidationHook<TPluginEvents>
  preprocess?: ProcessingHook<TPluginEvents>
  process?: ProcessingHook<TPluginEvents>
  complete?: ProcessingHook<TPluginEvents>
}

/**
 * Storage plugin hooks (upload, download, delete from remote storage)
 */
export type StoragePluginHooks<TUploadResult = any, TPluginEvents extends Record<string, any> = Record<string, never>> = {
  upload: UploadHook<TUploadResult, TPluginEvents>
  getRemoteFile?: GetRemoteFileHook<TPluginEvents>
  remove?: RemoveHook<TPluginEvents>
}

/**
 * All possible plugin hooks (for internal use)
 */
export type PluginHooks<TUploadResult = any, TPluginEvents extends Record<string, any> = Record<string, never>> = {
  validate?: ValidationHook<TPluginEvents>
  preprocess?: ProcessingHook<TPluginEvents>
  process?: ProcessingHook<TPluginEvents>
  upload?: UploadHook<TUploadResult, TPluginEvents>
  getRemoteFile?: GetRemoteFileHook<TPluginEvents>
  remove?: RemoveHook<TPluginEvents>
  complete?: ProcessingHook<TPluginEvents>
}

/**
 * Processing plugin (validators, compressors, thumbnail generators)
 *
 * These plugins transform or validate files without handling storage.
 */
export interface ProcessingPlugin<TUploadResult = any, TPluginEvents extends Record<string, any> = Record<string, never>> {
  id: string
  hooks: ProcessingPluginHooks<TPluginEvents>
  options?: UploadOptions
  events?: TPluginEvents
}

/**
 * Storage plugin (Azure, S3, GCS, etc.)
 *
 * Storage plugins handle uploading, downloading, and deleting files from remote storage.
 * Only one storage plugin can be active at a time.
 */
export interface StoragePlugin<TUploadResult = any, TPluginEvents extends Record<string, any> = Record<string, never>> {
  id: string
  hooks: StoragePluginHooks<TUploadResult, TPluginEvents>
  options?: UploadOptions
  events?: TPluginEvents
}

/**
 * Base plugin interface (for internal use - supports both types)
 */
export interface Plugin<TUploadResult = any, TPluginEvents extends Record<string, any> = Record<string, never>> {
  id: string
  hooks: PluginHooks<TUploadResult, TPluginEvents>
  options?: UploadOptions
  events?: TPluginEvents
}

/**
 * Define a processing plugin (validators, compressors, thumbnail generators)
 *
 * @example Validator
 * ```typescript
 * export const ValidatorMaxFiles = defineProcessingPlugin<ValidatorOptions>((options) => ({
 *   id: 'validator-max-files',
 *   hooks: {
 *     validate: async (file, context) => {
 *       if (context.files.length >= options.maxFiles) {
 *         throw { message: 'Too many files' }
 *       }
 *       return file
 *     }
 *   }
 * }))
 * ```
 */
export function defineProcessingPlugin<TPluginOptions = unknown, TPluginEvents extends Record<string, any> = Record<string, never>>(
  factory: (options: TPluginOptions) => ProcessingPlugin<any, TPluginEvents>,
): (options: TPluginOptions) => ProcessingPlugin<any, TPluginEvents> {
  return factory
}

/**
 * Define a storage plugin (Azure, S3, GCS, etc.)
 *
 * Storage plugins MUST implement the `upload` hook and should return an object with a `url` property.
 *
 * @example Azure Storage
 * ```typescript
 * export const PluginAzureDataLake = defineStoragePlugin<AzureOptions, AzureEvents>((options) => ({
 *   id: 'azure-datalake-storage',
 *   hooks: {
 *     upload: async (file, context) => {
 *       const fileClient = await getFileClient(file.id)
 *       await fileClient.upload(file.data, { onProgress: context.onProgress })
 *       return { url: fileClient.url, blobPath: fileClient.name }
 *     },
 *     getRemoteFile: async (fileId, context) => {
 *       // ... fetch file metadata ...
 *     },
 *     remove: async (file, context) => {
 *       // ... delete file ...
 *     }
 *   }
 * }))
 * ```
 */
export function defineStoragePlugin<
  TPluginOptions = unknown,
  TUploadResult = any,
  TPluginEvents extends Record<string, any> = Record<string, never>,
>(
  factory: (options: TPluginOptions) => StoragePlugin<TUploadResult, TPluginEvents>,
): (options: TPluginOptions) => StoragePlugin<TUploadResult, TPluginEvents> {
  return factory
}

/**
 * Define an uploader plugin with type safety, context access, and custom events.
 * This is the universal plugin factory for all plugin types (storage, validators, processors).
 *
 * @deprecated Use defineProcessingPlugin or defineStoragePlugin instead for better type safety
 *
 * Hooks receive context as a parameter, making it clear when context is available.
 * Context includes current files, options, and an emit function for custom events.
 *
 * @example Basic Plugin
 * ```typescript
 * export const ValidatorMaxFiles = defineUploaderPlugin<ValidatorOptions>((options) => ({
 *   id: 'validator-max-files',
 *   hooks: {
 *     validate: async (file, context) => {
 *       if (context.files.length >= options.maxFiles) {
 *         throw { message: 'Too many files' }
 *       }
 *       return file
 *     }
 *   }
 * }))
 * ```
 *
 * @example Plugin with Custom Events
 * ```typescript
 * type CompressionEvents = {
 *   start: { file: UploadFile; originalSize: number }
 *   complete: { file: UploadFile; savedBytes: number }
 * }
 *
 * export const PluginImageCompressor = defineUploaderPlugin<
 *   ImageCompressorOptions,
 *   CompressionEvents
 * >((options) => ({
 *   id: 'image-compressor',
 *   hooks: {
 *     process: async (file, context) => {
 *       context.emit('start', { file, originalSize: file.size })
 *       // ... compression logic ...
 *       context.emit('complete', { file, savedBytes: 1000 })
 *       return file
 *     }
 *   }
 * }))
 *
 * // Usage - events are automatically prefixed with plugin ID
 * uploader.on('image-compressor:complete', ({ file, savedBytes }) => {
 *   console.log(`Saved ${savedBytes} bytes`)
 * })
 * ```
 */
export function defineUploaderPlugin<TPluginOptions = unknown, TPluginEvents extends Record<string, any> = Record<string, never>>(
  factory: (options: TPluginOptions) => Plugin<any, TPluginEvents>,
): (options: TPluginOptions) => Plugin<any, TPluginEvents> {
  return factory
}

/**
 * INTERNAL TYPES - Not commonly needed by users
 * Kept exported for edge cases but not primary API
 */

export type PreProcessor = (file: UploadFile) => Promise<UploadFile>
export type Uploader = (
  file: Readonly<UploadFile>,
  emiter: Emitter<Pick<UploaderEvents, "upload:error" | "upload:progress">>,
) => Promise<string>
export type Validator = (file: UploadFile) => Promise<boolean | FileError>
export type Processor = (file: UploadFile) => Promise<File | Blob>

export interface UploadBlob {
  blobPath: string
}

type MinimumRemoteFileAttributes = {
  size: number
  mimeType: string
  remoteUrl: string
  preview?: string
}
